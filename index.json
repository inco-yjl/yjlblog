[{"content":"javascript 数组 API 数组API中的纯函数 纯函数：\n不改变源数组（没有副作用）\n返回一个数组\nconcat\nmap 逐个映射 arr.map(num =\u0026gt; num * 2)/arr.map(function(num){ return num*2 })\nfilter 对数组中每个元素进行检查 arr.filter(num =\u0026gt; num\u0026gt;15)/arr.map(function(num){ return num\u0026gt;15})\nslice 返回数组切片，包含start不包含end，如果end不指定，则一直到结尾；如果都不指定，则返回全部\nsplice与slice区别：\nslice是切片，splice是剪接。改变原数组，返回值是剪接后的数组。传参：开始索引、剪掉的元素个数、要加入的元素、……\n","permalink":"https://intpyjl.github.io/yjlblog/posts/tech/frontend_interview2/","summary":"准备百度面试","title":"前端知识点Js"},{"content":"css 三种布局 盒模型 传统的布局解决方式。在 CSS 中广泛地使用两种“盒子” —— 块级盒子 (block box) 和 内联盒子 (inline box)。这两种盒子会在页面流（page flow）和元素之间的关系方面表现出不同的行为。完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content —— 合在一起就可以创建我们在页面上看到的内容。盒子的实际宽度=content + border + padding\n外边距是盒子周围一圈看不到的空间。它会把其他元素从盒子旁边推开。外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。理解外边距的一个关键是外边距折叠的概念。如果你有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小。\n对内联盒子应用宽度、高度、边距、边框和内边距。宽度和高度不会起作用。外边距(横向)、内边距和边框是生效的，但盒子的内联性质不会改变，因此内边距和边框会与段落中的其他单词重叠。如果对display属性设置值inline-block，则既可以实现inline的不换行，同时width/height又可以发挥作用。\nI am a paragraph and this is a span inside that paragraph. A span is an inline element and so does not respect width and height. span{ margin: 50px; padding: 10px; width: 100px; height: 0px; background-color: lightblue; border: 2px solid blue; } 定位规则 普通流：按照次序依次定位每个盒子 浮动：将盒子从普通流中单独拎出来，将其放到外层盒子的某一边 绝对定位：按照绝对位置来定位盒子，其位置根据盒子的包含元素所建立的绝对坐标系来计算，因此绝对定位元素有可能会覆盖其他元素 普通流\n依次排列。块盒子在垂直方向依次排列；行内盒子水平依次排列\n当css的position属性为static或relative，并且无float属性值时为普通流布局。\n浮动\n在浮动定位中，浮动盒子会浮动到当前行的开始或尾部位置。这会导致普通流中的文本及其他内容会“流”到浮动盒子的边缘处，除非元素通过 clear 清除了周围的浮动。行盒子会伸缩以适应浮动盒子的大小。\nclear 属性可设置以下值之一：\nnone - 允许两侧都有浮动元素。默认值 left - 左侧不允许浮动元素 right- 右侧不允许浮动元素 both - 左侧或右侧均不允许浮动元素 inherit - 元素继承其父级的 clear 值 绝对定位\n在绝对定位中，盒子会完全从当前流中移除，并且不会再与其有任何联系（此处仅指定位和位置计算，而绝对定位的元素在文档树中仍然与其他元素有父子或兄弟等关系），其位置会使用 top、bottom、left 和 right 相对其包含块进行计算。\n如果元素的 position 为 absolute 或 fixed，该元素为绝对定位。\n对position: fixed的元素来说，该元素相对视口进行绝对定位，因此滚动时元素的位置并不会改变。\n综上，盒模型依赖display + position + float这三个属性值来定位。\nflex布局 flexbox是一种一维的布局模型，它给 flexbox 的子元素之间提供了强大的空间分布和对齐能力。 flexbox的两根轴线 flex布局中有两根轴线：主轴和交叉轴。主轴由 flex-direction 定义，另一根轴垂直于它。\n主轴\nflex-direction 可以取 4 个值：\nrow(初始值) row-reverse column column-reverse 主轴，也就是排列的方向。当选值为row，主轴将沿横向(inline)延伸，当选值为column，主轴将沿纵向(block)延伸。交叉轴则相反。\n注意flexbox方向与书写方向(左右顺序)无关。reverse改变的是子元素的排列顺序（或者说改变的是起始线和终止线的位置）。\ndisplay值为flex的区域就叫flex容器，容器中的直系子元素会变为flex元素。如果容器中一些元素比其他元素高，那么元素会沿交叉轴被拉伸来填满它的大小。\n多行flex容器 虽然flexbox是一维模型，但设置flex-wrap: wrapflex布局可以应用到多行，这时候把每一行可以看作一个新的flex容器。任何空间分布都将在该行上发生，而不影响该空间分布的其他行。\n现在，如果子元素无法全部显示在一行中，则会换行显示。若将display其设置为nowrap(初始值)，子元素将会缩小以适应容器(这取决于其他属性的值，初始值会缩小)，若不然，使用nowrap会导致溢出。\nflex元素的控制属性 flex-basis flex-shrink flex-grow 用以实现flex元素自动填充剩余空间。\nflex-basis: 默认值为auto，此时按照设置的元素尺寸或自动按照元素内容的尺寸。如果设置值，为主轴的假定尺寸（会覆盖width/height，但会受到min-width/max-width等值的影响）\nflex-grow: 若被设置为正整数，flex 元素会以 flex-basis 为基础，沿主轴方向增长尺寸，并占据此方向轴上的可用空间。若有多个元素进行延展，会按照flex-grow的值分配权重。\nflex-shrink: 若设置为正整数，则是用于控制 flex 元素收缩的程度，伸缩权重是flex-shrink × flex-basis。\n可以用flex属性进行简写。\nflex: initial 是把 flex 元素重置为初始值，它相当于 flex: 0 1 auto。flex-grow 的值为 0，所以 flex 元素不会超过它们 flex-basis 的尺寸。flex-shrink 的值为 1, 所以可以缩小 flex 元素来防止它们溢出。flex-basis 的值为 auto. Flex 元素尺寸可以是在主维度上设置的，也可以是根据内容自动得到的。 flex: auto等同于flex: 1 1 auto flex: none等同于flex: 0 0 auto flex: 2 等同于 flex: 2 1 0 设置flex-basis为0，完全按flex-grow来占用剩余空间，若另外的元素尺寸就已经超过容器尺寸，会占据最小大小。 对齐和空间分配 flexbox 的一个关键特性是能够设置 flex 元素沿两根轴线对齐方式，以及它们之间的空间分配。\nalign-items: 使元素在交叉轴方向对齐，默认值stretch使flex元素默认被拉到最高来填满容器。\n取值：\nstretch\nflex-start: 按容器顶部对齐\nflex-end: 按容器下部对齐\ncenter: 居中对齐\nOne Two Three has extra text justify-content: 使元素在主轴方向上对齐,初始值是flex-start，元素从容器的起始线排列。\nstretch flex-start: 从起始线开始排列 flex-end: 从终止线开始排列 center: 居中对齐 space-around: 剩余空间在主轴方向环绕所有子元素均分 space-between: 剩余空间在主轴方向所有子元素之间均分 如果设置了flex-grow，space-around、space-between不会起效\nOne Two Three has extra text Grid布局 ","permalink":"https://intpyjl.github.io/yjlblog/posts/tech/frontend_interview1/","summary":"准备百度面试","title":"前端知识点CSS"},{"content":" 1.下列程序的运行结果是什么？ 1 2 3 4 5 6 7 8 function getPersonInfo (one, two, three) { console.log(one) console.log(two) console.log(three) } const person = \u0026#39;Lydia\u0026#39; const age = 21 getPersonInfo `${person} is ${age} years old` A. “Lydia” 21 [“”, “ is ”, “ years old”]\nB. [“”, “ is ”, “ years old”] “Lydia” 21\nC. “Lydia” [“”, “ is ”, “ years old”] 21\nD. Reference Error\n模板字符串\n模板字符串可以包含特定语法（${expression}）的占位符。占位符中的表达式和周围的文本会一起传递给一个默认函数，该函数负责将所有的部分连接起来。如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用。\n标签使您可以用函数解析模板字符串。标签函数的第一个参数包含一个字符串值的数组。其余的参数与表达式相关。\n答案：B\n2.关于将 Promise.all 和 Promise.race 传入空数组的两段代码的输出结果说法正确的是 1 2 3 4 5 6 Promise.all([]).then((res) =\u0026gt; { console.log(\u0026#39;all\u0026#39;); }); Promise.race([]).then((res) =\u0026gt; { console.log(\u0026#39;race\u0026#39;); }); A.all 和 race 都会被输出\nB.all 和 race 都不会被输出\nC.all 会被输出，而 race 不会被输出\nD.all 不会被输出，race 会被输出\nPromise.all: 将多个Promise实例包装成一个Promise实例。\n如果传入的参数是一个空的可迭代对象，则返回一个已完成（already resolved）状态的 Promise。 如果传入的参数不包含任何 promise，则返回一个异步完成（asynchronously resolved）Promise。注意：Google Chrome 58 在这种情况下返回一个已完成（already resolved）状态的 Promise。 其他情况下返回一个处理中（pending）的Promise。这个返回的 promise 之后会在所有的 promise 都完成或有一个 promise 失败时异步地变为完成或失败。返回值将会按照参数内的 promise 顺序排列，而不是由调用 promise 的完成顺序决定。 Promise.all: 赛跑。一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。如果传的迭代是空的，则返回的 promise 将永远等待。\n答案：C\n3.以下使用 typeof 操作符的代码的输出结果是？ 1 2 3 4 var x = typeof x console.log(x) var res = typeof typeof x; console.log(res) typeof的返回值是字符串类型，所以是string\n4.关于html的canvas的绘制、缩放，下列说法正确的是？ A. 图像绘制在canvas元素之外也可见\nB。 使用 drawImage方法绘制的图片可以用css3的tramsform:scale的属性实现缩放\nC. 默认情况下，canvas是一个可以获取焦点的元素\nD. 其他3个选项都不正确\nA: 好像是对的？\nB: 不是css，而是js的context.transform方法。context：渲染上下文对象\nC: 不能直接获得，可以通过以下代码获得：\n1 2 3 4 5 canvas.setAttribute(\u0026#39;tabindex\u0026#39;, \u0026#39;0\u0026#39;); // tabindex指示元素是否可以聚焦 canvas.addEventListener(\u0026#39;click\u0026#39;, function() { canvas.focus(); }); canvas.focus(); 注意canvas如果在css中设置宽高，可能导致图案变形，这时就使用canvas本身的宽高属性\n答案：D\n5.下面这段代码在浏览器中渲染出来的div高度是多少 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .heightTest { height: 1000px; min-height: 500px; max-height: 300px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;heightTest\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; max-height会覆盖height，而min-height会覆盖max-height\n=\u0026gt;max-height和height取小值，min-height和height取大值\n答案：500px\n6.如何仅获得下述值为3的DOM节点引用(不包含其他元素) 1 2 3 4 5 6 \u0026lt;ul class=\u0026#39;aaa\u0026#39;\u0026gt; \u0026lt;li class=\u0026#39;bbb\u0026#39;\u0026gt;1\u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#39;ccc\u0026#39;\u0026gt;2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;3\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;4\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; A .aaa \u0026gt; li\nB .bbb ~ li\nC .ccc ~ li\nD .ccc + li\ncss选择器:\n组合器\n后代选择器：所有后代节点 A B\n直接子代组合器：A B\n一般兄弟组合器：后一个节点在前一个节点后面的任意位置，且共享同一个父节点 A ~ B\n紧邻兄弟组合器：A节点后紧跟的兄弟节点B A + B\n列组合器：col || td,匹配表格列内所有\u0026lt;td\u0026gt;\n分组选择器\n选择器列表：,将不同的选择器结合起来\n伪选择器\n:按状态信息来选择元素\n::用于表示无法用 HTML 语义表达的实体。p::first-line匹配所有\u0026lt;p\u0026gt;元素的第一行。\n答案：D\n7.下面哪个选项不能实现除第一个标签外的标签字体都为红色，即如下注释效果 1 2 3 4 5 \u0026lt;ul class=\u0026#34;word\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;text\u0026#34;\u0026gt;1\u0026lt;/li\u0026gt; //字体为黑色 \u0026lt;li class=\u0026#34;text\u0026#34;\u0026gt;2\u0026lt;/li\u0026gt; //字体为红色 \u0026lt;li class=\u0026#34;text\u0026#34;\u0026gt;3\u0026lt;/li\u0026gt; //字体为红色 \u0026lt;/ul\u0026gt; A .text ~ .text { color: red; }\nB .word:not(:first-child) { color: red; }\nC .text:nth-last-child(2){ color: red; }\nD .text + .text { color: red; }\nA: 对第一个标签应用，即可使后面两个标签均为红色\nB: 可匹配除第一个元素之外的元素\nC: 仅匹配倒数第二个元素，即只有第一个标签为红色\nD: 匹配每个.text后的紧邻元素，则除了第一个都为红色\n答案：C\n8.内存泄漏是 javascript 代码中必须尽量避免的，以下几段代码可能会引起内存泄漏的有（） (1)\n1 2 3 4 function getName() { name = \u0026#39;javascript\u0026#39; } getName() (2)\n1 2 3 4 5 6 7 const elements = { button: document.getElementById(\u0026#39;button\u0026#39;) }; function removeButton() { document.body.removeChild(elements.button); } removeButton() (3)\n1 2 3 4 5 6 let timer = setInterval(() =\u0026gt; { const node = document.querySelector(\u0026#39;#node\u0026#39;) if(node) { clearInterval(timer) } }, 1000); A. (1)、（2）、（3）\nB. (2)、（3）\nC. (1)、（3）\nD. (1)、（2）\njs内存泄漏：\n内存泄漏：程序不再使用或不需要的一块内存，但是由于某种原因没有被释放仍然被不必要的占有。在代码中创建对象和变量会占用内存，但是javaScript是有自己的内存回收机制，可以确定那些变量不再需要，并将其清除。但是代码中存在逻辑缺陷的时候，一些已经不需要的变量在程序中还存在着引用。\n常见情况\n1.全局变量： 在非严格模式下当引用未声明的变量时，会在全局对象中创建一个新变量。在浏览器中，全局对象将是window。全局变量无法被垃圾回收机制回收。所以（1）中情况会造成内存泄漏。\n2.DOM引用： 如（2）中情况，删除了DMO节点，但保留了引用，导致DOM元素没有被回收。值得注意的是子节点的引用问题，如果删除父节点但仍有子元素的引用在，可能导致整个父元素仍保留在内存中。\n3.被遗忘的定时器和回调函数： setInterval不会清除定时器队列，需要在定时器完成工作时，手动清楚定时器，否则回调函数及其内部引用对应的数据不会被回收。\n4.闭包：\n1 2 3 4 5 6 7 8 9 10 11 12 var fn =function(){ var sum = 0 return function(){ sum++ console.log(sum); } } fn1=fn() fn1() //1 fn1() //2 fn1() //无法被回收 fn1 = null //手动释放 答案：D\n9.对于一个数字组成的数组 nums，现在需要执行在不改动 nums 的基础上去重操作，返回一个新的无重复元素的数组，以下几段代码能完成这一操作的是? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 (1) const newNums = Array.from(new Set(nums)) (2) const newNums = nums.filter((n, i) =\u0026gt; { return nums.indexOf(n) === i }) (3) const newNums = nums.forEach((n, i) =\u0026gt; { return nums.indexOf(n) === i }) (4) const newNums = nums.reduce((acc, n, i) =\u0026gt; { return [].concat(acc, nums.indexOf(n) === i ? n : [] ) }) A. (1)、（2）、（3）、（4）\nB. (1)、（3）、（4）\nC. (1)、（2）、（4）\nD. (1)、（4）\njs数组去重：\n利用Set()+Array.from(): Set对象：是值的集合，你以按照插入的顺序迭代它的元素。Set中的元素是唯一的。\nArray.from() 方法：对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。\nfilter+indexOf filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 利用数组的indexOf方法:返回第一次出现指定值的索引。\n（forEach() 方法按顺序为数组中的每个元素调用一次函数。）\nreduce() 方法接收一个函数作为累加器,reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（上一次回调的返回值），当前元素值，当前索引，原数组。(4)中利用数组作为每次回调的返回值，indexOf作为判断方法 答案：C\n10.利用 sourcemap 定位线上 js 问题是必须掌握的技能，以下关于 sourcemap 文件说法不正确的是（） A. 利用 sourcemap 可以定位到具体的出错代码文件的行、列信息\nB. sourcemap 文件通过记录列号的相对位置来提高性能\nC. 在 chrome 渲染过程中，请求完 js 文件后会立即尝试请求对应的 sourcemap 文件并解析\nD. sourcemap 文件使用了 VLQ 编码做映射表\nsourcemap\nSource Map 就是一个信息文件，里面存储了代码打包转换后的位置信息，实质是一个 json 描述文件，维护了打包前后的代码映射关系。在Webpack（或其他打包工具）构建代码中，开启 Source Map 重新构建，就可以使用相关功能。\n打包编译后的 bundle.js.map 文件中，mappings（映射）属性的值是：AAAA; AACA, c。这是一个字符串，它分成三层：\n第一层是行对应，以分号（; ）表示，每个分号对应转换后源码的一行。\n第二层是位置对应，以逗号（, ）表示，每个逗号对应转换后源码的一个位置。\n第三层是位置转换，以VLQ 编码表示，代表该位置对应的转换前的源码位置。\n所以该字符串表示转换后的源码分成两行，第一行有一个位置，第二行有两个位置。\n以AAAA 举例，转换后得到 [0, 0, 0, 0] ，所以代表的含义分别是；压缩代码的第一列、第一个源代码文件，即index.js、 源代码的第一行、 源代码第一列\nC： 需要使用开发者工具，勾选\u0026quot;Enable source maps\u0026quot;。\n答案：C\n11.对一网站做渗透测试，目标站点由wordpress搭建，请问下面操作最为合适的是? A. 访问robots.txt，查看站点结构及敏感目录\nB. 使用wpscan对网站进行扫描\nC. 使用appscan或awvs对网站进行漏洞扫描\nD. 寻找网站后台，进行暴力破解登录账号密码\n渗透测试\n渗透测试就是通过一些手段来找到网站，APP，网络服务，软件，服务器等网络设备和应用的漏洞，告诉管理员有哪些漏洞，怎么填补，从而防止黑客的入侵。\n网站敏感目录\nrobots.txt 文件是专门针对搜索引擎机器人robot 编写的一个纯文本文件。我们可以在这个文件中指定网站中不想被robot访问的目录。这样，我们网站的部分或全部内容就可以不被搜索引擎收录了，或者让搜索引擎只收录指定的内容。\nwpscan为wordpress站点专用扫描工具，可扫描wordpress版本、插件及漏洞、用户名泄露、暴力破解接口等。\n答案：B\n12.关于网络请求延迟增大的问题，以下哪些描述是正确的() A. 使用ping来测试 TCP 端口是不是可以正常连接\nB. 使用tcpdump 抓包分析网络请求\nC. 使用strace观察进程的网络系统调用\nD. 使用Wireshark分析网络报文的收发情况\nping是基于ICMP协议不能测试TCP\n答案：BCD\n13. 下面可以按照从小到大顺序排列显示磁盘中各个分区利用率的命令是 A. du | grep -o \u0026quot;\\\u0026lt;[0-9]*%.*\u0026quot; -o | sort -n\nB. df | grep -o \u0026quot;\\\u0026lt;[0-9]*%.*\u0026quot; -o | sort -r\nC. df | grep -o \u0026quot;\\\u0026lt;[0-9]*%.*\u0026quot; -o | sort -n\nD. du | grep -o \u0026quot;\\\u0026lt;[0-9]*%.*\u0026quot; -o | sort -m\ndf:显示目前在 Linux 系统上的文件系统磁盘使用情况统计 du:前所在文件夹的总磁盘占用量\nsort -r降序， -n升序\n答案：C\n14.如下伪码实现了简单的消费者的功能\n1 2 3 4 5 6 7 8 9 void consumption() { while(____){ ____; } P(mutex); 队列里面取一个元素; V(mutex); ————————; } 里面的P,V就是指PV操作，mutex是互斥信号量；现有如下方法：\nisFull() : 表示队列元素满了 isEmpty(): 表示队列元素为空 m_notFull.wait(): 阻塞当前进程，直到队列元素不满 m_notFull.notify(): 队列元素不满了，唤醒某个进程 m_notEmpty.wait()：阻塞当前进程，直到队列元素不为空 m_notEmpty.notify():队列元素不为空了，唤醒某个进程 请你按选好方法，填到上面空行，完成消费者的功能 让生产者在缓冲区满时休眠，等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒，开始往缓冲区添加数据。让消费者在缓冲区空时进入休眠，等到生产者往缓冲区添加数据之后，再唤醒消费者。\nmutex是互斥信号量，一般为1，实现对缓冲区的互斥访问\n答案：isEmpty(),m_notEmpty.wait(),m_not_Full.notify()\njs数据类型 Number、String、Boolean、undefined、object、Null\n","permalink":"https://intpyjl.github.io/yjlblog/posts/tech/frontend2/","summary":"练习百度的前端笔试题2","title":"前端笔试题练习（二）"},{"content":"求从l到r中所有数字的异或和 f(b)=1 xor 2 xor …… xor b 当b%4=0时：f(b)=b 当b%4=1时：f(b)=1 当b%4=2时：f(b)=b+1 当b%4=3时：f(b)=0\ncal(l,r)=cal(1,r) xor cal(1,l);\n保存class为js-input的输入框的dom元素引用 this.input = document.querySelector('.js-input');或document.getElementsByClassName(\u0026quot;js-input\u0026quot;)[0];\n1 2 3 4 5 6 7 8 input.addEventListener(\u0026#39;keydown\u0026#39;, function (event) { // 请修改这一行代码，判断用户是否按了回车键 var isEnter = event.keyCode === 13;//通过keyCode // 请修改这一行代码，判断用户是否按了删除键 var isDelete = event.keyCode === 8; …… }); ","permalink":"https://intpyjl.github.io/yjlblog/posts/tech/code1/","summary":"练习百度的前端笔试题","title":"编程题练习（一）"},{"content":" 1.下列程序的运行结果是什么？ 1 2 3 4 5 6 7 8 9 10 11 setTimeout(function(){ console.log(1); }, 0) new Promise(function(resolve){ console.log(2); resolve(); console.log(3); }).then(function(){ console.log(4); }) console.log(5); Promise 构造函数接受一个函数作为参数，该函数是同步的并且会被立即执行，所以我们称之为起始函数。起始函数包含两个参数 resolve 和 reject，分别表示 Promise 成功和失败的状态。起始函数执行成功时，它应该调用 resolve 函数并传递成功的结果。当起始函数执行失败时，它应该调用 reject 函数并传递失败的原因。\nPromise 构造函数返回一个 Promise 对象，该对象具有then方法，用于处理 Promise 成功状态的回调函数。then方法指定的回调函数将在当前脚本所有同步任务执行完后才会执行。所以3在4之前执行，4在5之后执行。\nPromise属于JavaScript引擎内部任务，而setTimeout则是浏览器API，而引擎内部任务优先级高于浏览器API任务，所以1最后输出。\n答案：2 3 5 4 1\n2.下列布局在页面上的宽度比是多少？ 1 2 3 4 5 6 7 8 9 10 11 12 13 .flex { display: flex; width: 200px; height: 100px; } .left { flex: 3 2 50px; background: red; } .right { flex: 2 1 200px; background: blue; } 1 2 3 4 \u0026lt;div class=\u0026#34;flex\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; flex: flex-grow flex-shrink flex-basis\nflex-shrink × flex-basis 得出的是子元素总宽度超过父元素宽度时的收缩权重。\n答案：1:5\n3.下列代码的执行结果 1 2 3 4 5 6 7 function sayHello() { console.log(name); console.log(age); var name = \u0026#34;Tom\u0026#34;; let age = 18; } sayHello(); 答案：undefined，ReferenceError\nvar和let的区别：\n变量提升： 当浏览器开辟出供代码执行的栈内存后，代码并没有自上而下立即执行，而是继续做了一些事情：把当前作用域中所有带var/function关键字的进行提前的声明和定义 =\u0026gt; 变量提升机制。let不存在该机制\n默认值： var如果只声明没有赋值，默认值是undefined。而如果let的值在定义前使用，会报ReferenceError\n重复声明： var允许重复声明，而let声明的变量（在同一作用域中）不允许任何关键词的重复声明。重复声明被视作语法错误，代码一步都不会执行。\n暂时性死区：\n一个未声明的值a\n1 2 console.log(a) // =\u0026gt; ReferenceError: a is not defined 但是typeof一个未声明的值a\n1 2 console.log(typeof a) // =\u0026gt; \u0026#39;undefined\u0026#39; 这是浏览器的bug，本应报错，因为没有a（暂时性死区） typeof一个let声明的值a\n1 2 3 console.log(typeof a) // =\u0026gt; ReferenceError: Cannot access \u0026#39;a\u0026#39; before initialization let a 执行顺序\n1 2 3 4 5 for (var i = 0; i \u0026lt; 3; i++) { setTimeout(_ =\u0026gt; { console.log(i) }) } 输出：333\nsetTimeout和循环内部的执行是异步的，其优先执行完后再执行setTimeout内容。var声明的变量会覆盖之前的声明\n1 2 3 4 5 for (let i = 0; i \u0026lt; 3; i++) { setTimeout(_ =\u0026gt; { console.log(i) }) } 输出：012\nlet在此定义的作用域是在函数的块内 (这里的 i 是函数局部变量)，每一次循环的 i 是相互独立的(属于不同作用域)\n4.关于html语义化，以下说法错误的是？ A.对表单分组的标题需要使用 label 标签包裹\nB.对生僻字标注拼音需要使用 ruby 标签包裹\nC.对引用文献需要使用 cite 标签包裹\nD.fieldset 标签用来对表单进行分组\nhtml语义化\n将 \u0026lt;label\u0026gt; 和一个 \u0026lt;input\u0026gt; 元素相关联，为input元素定义标注，改进了表单控件的可用性；当你点击到label标签时，会自动聚焦到对应控件上\n\u0026lt;ruby\u0026gt;被用来展示东亚文字注音或字符注释\n\u0026lt;cite\u0026gt;表示一个作品的引用，且必须包含作品的标题\n\u0026lt;fieldset\u0026gt;元素将一个 HTML 表单的一部分组成一组，内置了一个\u0026lt;legend\u0026gt;元素作为 fieldset 的标题。即A应是\u0026lt;legend\u0026gt;。以下是一个实例\nSimple fieldset Spirit of radio Music Type 答案：A\n5.linux下可以查看网卡流量情况的是 sar /proc/net/dev ifstat iftop nload iptraf-ng nethogs 6.那么对于文件上传漏洞，有效防御手段有哪些？ A.浏览器端限制文件扩展名\nB.服务器端限制文件扩展名\nC.将上传的文件存储在静态文件服务器中\nD.验证Content-Type\n文件上传漏洞是web安全中经常用到的一种漏洞形式。是对数据与代码分离原则的一种攻击。上传漏洞顾名思义，就是攻击者上传了一个可执行文件如木马、病毒、恶意脚本如PHP、ASP等执行文件等到服务器执行，并最终获得网站控制权限的高危漏洞。\n一般来说文件上传过程中检测部分由客户端javascript检测、服务端Content-Type类型检测、服务端path参数检测、服务端文件扩展名检测、服务端内容检测组成。但这些检测并不完善，且都有绕过方法。\nA:可以把木马php伪造成jpg绕过，制作一句话图片木马\nD:服务端MIME检测绕过（Content-Type检测）：使用burp代理，修改Content-Type的参数\nB貌似也不行\n答案：BC\n7. 关于以下代码，说法正确的有哪些？ 1 2 function Person() { } var person = new Person(); A.每一个原型都有一个constructor属性指向关联的构造函数。\nB. 每一个对象都有一个prototype属性。\nC. Object.getPrototypeOf(person) === Person.prototype\nD. person.constructor === Person\njs原型\n1 2 3 4 5 6 7 8 function Person(age) { this.age = age } Person.prototype.name = \u0026#39;kavin\u0026#39; var person1 = new Person() var person2 = new Person() console.log(person1.name) //kavin console.log(person2.name) //kavin 在JavaScript中，每个函数都有一个prototype属性，这个属性指向函数的原型对象。上述例子中，函数的prototype指向了一个对象，而这个对象正是调用构造函数时创建的实例的原型，也就是person1和person2的原型。\n每一个javascript对象(除null外)创建的时候，就会与之关联原型，每一个对象都会从原型中“继承”属性。\n1 2 3 4 5 function Person() { } var person = new Person(); console.log(person.__proto__ === Person.prototype);//true //Object.getPrototypeOf(person) 每个对象(除null外)都会有的属性，叫做__proto__，这个属性会指向该对象的原型。 构造函数\n1 2 3 4 function Person() { } console.log(Person===Person.prototype.constructor) //true //person.constructor === Person.prototype.constructor 每个原型都有一个constructor属性，指向该关联的构造函数 原型链\n1 console.log(Object.prototype.__proto__ === null) // true 每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么假如我们让原型对象等于另一个类型的实例，结果会怎样？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。\n(因为原型也是对象，所以是Object的实例) 答案：ACD\n8.关于同源策略和跨域的问题，以下说法正确的有？ A.http://store.company.com/dir/page.html 和 http://store.company.com/dir/other.html 不同源。\nB. node设置res.header(\u0026ldquo;Access-Control-Allow-Origin\u0026rdquo;, \u0026ldquo;*\u0026rdquo;) 去解决跨域问题，会有安全问题。\nC. JSONP的原理是利用引入script不限制源的特点，把处理函数名作为参数传入，然后返回执行语句。\nD. document.domain的原理是将两个页面的document.domain设置成一致，只能解决主域相同的跨域问题。\n同源\n协议/主机/端口元组相同。\n跨域\n跨域的安全限制都是对浏览器端来说的，服务器端是不存在跨域安全限制的。浏览器的同源策略限制从一个源加载的文档或脚本与来自另一个源的资源进行交互。\n跨源资源共享（CORS）\nCORS是一种基于 HTTP Headers的机制。跨域的目标服务器返回的响应报文包含了正确 CORS 响应头，则允许 Web 应用服务器进行跨源访问控制，从而使跨源数据传输得以安全进行。\n其中最敏感的就是 Access-Control-Allow-Origin 这个 Header, 他是W3C标准里用来检查该跨域请求是否可以被通过。 (Access Control Check) 跨域实现的过程大致如：\n从http://www.a.com/test.html 发起一个跨域请求，请求的地址为： http://www.b.com/test.php，如果 服务器B返回一个如下的header Access-Control-Allow-Origin: http://www.a.com\n那么，这个来自http://www.a.com/test.html 的跨域请求就会被通过。 在这个过程中， request 还会带上这个header：Origin: http://www.a.com\nJSONP\nJSONP是一种非正式传输协议，该协议的一个要点就是允许用户传递一个callback(或者一开始就定义一个回调方法)参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。\n可以发现，在web页面调用js文件是不受是否跨域问题的影响的。而且凡是拥有src/href这类属性的标签都拥有跨域的能力，比如img和script。这本质上就是一个GET请求。jsonp的实现原理其实就是利用了这个。\n实现方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 前端部分 \u0026lt;script\u0026gt; //callback function onResponse(posts) { console.log(posts); } \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;http://localhost:9090/api\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; //后端部分 const http = require(\u0026#39;http\u0026#39;); http.createServer((req, res) =\u0026gt; { if (req.url === \u0026#39;/api\u0026#39;) { let posts = [\u0026#39;js\u0026#39;, \u0026#39;php\u0026#39;]; res.end(`onResponse(${JSON.stringify(posts)})`); } }) .listen(9090, () =\u0026gt; { console.log(9090) }) 前端script中的src请求完毕以后，后端会给前端返回一个字符串onResponse([\u0026quot;js\u0026quot;,\u0026quot;php\u0026quot;])，因为script标签的原因，浏览器会把这一段字符串当做js来执行。这样我们一开始在前端定义好了的回调就会执行，我们就拿到数据了。\n利用document.domain实现跨域\n前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。 document.domain属性赋值是有限制的，只能赋成当前的域名或者基础域名。\n两个子域名：\naaa.xxx.com\nbbb.xxx.com\naaa里的一个网页（a.html）引入了bbb 里的一个网页（b.html），这时a.html里同样是不能操作b.html里面的内容的。因为document.domain不一样，一个是aaa.xxx.com，另一个是bbb.xxx.com。\n这时就可以通过Javascript，将两个页面的domain改成一样的，需要在a.html里与b.html里都加入：\ndocument.domain = \u0026ldquo;xxx.com\u0026rdquo;;\n这样这两个页面就可以互相操作了。也就是实现了同一基础域名之间的\u0026quot;跨域\u0026quot;。\n答案：BCD\n9.以下关于CSS盒模型，说法正确的是： A. 盒模型相关CSS属性包含：宽高、内边距、边框和外边距。\nB. 如果\u0026lt;p\u0026gt;的纵向margin是12px，那么两个\u0026lt;p\u0026gt;之间纵向的距离是12px。\nC. 在CSS中，增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。\nD. 盒子的实际宽度=宽度+左填充+右填充+左边框+右边框+左边界+右边界。\nA???\nB: margin纵向塌陷现象：小的margin会塌陷到大的margin中，从而margin不叠加，只以大值为准。相邻元素的margin-top和margin-bottom 会发生重叠；空白内容的P标签、div标签等也会重叠。\nC: D: 盒子的实际宽度不包含margin\n答案：BC\n10.下列在 JS 事件循环机制中属于微任务（microTask）的是？ A. process.nextTick\nB. promise\nC. setTimeout\nD. setInterval\njs事件循环\njs是单线程执行的，所谓异步任务也是用同步的方式去模拟的。Event Loop是js的执行机制，就是先确定事件的执行规则，然后按照这个规则循环执行。\n任务和异步任务会分别进入不同的执行空间，同步任务进入主线程优先执行，异步的进入Event table，并注册该异步动作的回调函数。 当异步动作中指定的事情完成之后（比如发送请求给服务端），Event Table会将这个函数移入Event Queue（事件队列） 主线程内的任务执行完成之后，会有一段空置时间（很短），这个时候会去看Event Queue（事件队列）中找函数，如果有Event Queue中有需要执行的函数，那么就会把这个函数放入主线程进行执行。 以上的过程不断重复，形成了我们常说的Event loop（事件循环） 微任务/宏任务\n微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于他们的执行顺序。js线程在执行代码时正确的顺序是：同步任务\u0026ndash;\u0026gt; 微任务\u0026ndash;\u0026gt; 宏任务。每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务。\nmacro-task(宏任务)：包括整体代码script，setTimeout，setInterval，setImmediate\nmicro-task(微任务)：Promise，process.nextTick\nnextTick\nprocess.nextTick() 是 Node 的一个定时器，让任务可以在指定的时间运行。其中 Node 一共提供了 4 个定时器，它们分别是 setTimeout()、setInterval()、setImmediate()、process.nextTick()。\nprocess.nextTick() 这个名字有点误导，它是在本轮循环执行的，而且是所有异步任务里面最快执行的。\nNode 执行完所有同步任务，接下来就会执行process.nextTick的任务队列。基本上，如果你希望异步任务尽可能快地执行，那就使用 process.nextTick。\n1 2 process.nextTick(() =\u0026gt; console.log(3)); Promise.resolve().then(() =\u0026gt; console.log(4)); // 3 // 4 (都属于微任务，nextTick优先执行)\n1 2 3 4 process.nextTick(() =\u0026gt; console.log(1)); Promise.resolve().then(() =\u0026gt; console.log(2)); process.nextTick(() =\u0026gt; console.log(3)); Promise.resolve().then(() =\u0026gt; console.log(4)); // 1 // 3 // 2 // 4 上面代码中，全部 process.nextTick 的回调函数，执行都会早于 Promise 的。\n答案：AB\n11.如图片的地址为imgUrl,下面哪行代码在网页中打开可以直接看到的是文字“hello”？ A.\u0026lt;img src=“imgUrl” title=“hello”\u0026gt;\nB.\u0026lt;img src=“” title=“hello”\u0026gt;\nC.\u0026lt;img src=“” alt=“hello”\u0026gt;\nD.\u0026lt;img src=“imgUrl” alt=“hello”\u0026gt;\ntitle原本是悬浮显示的，但是图片出现错误显示不出来时也会显示（和alt一样）。但是alt优先级高\n答案：BC\n12.下列选项中，关于HTTP与HTTPS的区别的描述中，正确的是？ A.http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密传输协议。\nB.http和https使用的是完全不同的连接方式，用的端口也不一样。\nC.http的连接很简单，是无状态的。HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。\nD. http默认使用80端口，https默认使用403端口。\nA: HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好\nB: http 和 https 使用的是完全不同的连接方式，用的端口也不一样。HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。\nC: HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。\nD: HTTP 默认工作在 TCP 协议 80 端口,HTTPS 默认工作在 TCP 协议443端口\n答案：ABC\n13.下列关于 React 的生命周期的描述，正确的有哪些？ A. 组件的生命周期包括实例化、运行态和销毁期；\nB. 允许在 render 函数中执行 this.setState；\nC. componentDidMount 函数中可以获取到该组件的 dom 节点；\nD. React 16 提供的 componentDidCatch 方法，可以捕获构造函数、渲染和生命周期函数的异常；\n答案：ACD\n","permalink":"https://intpyjl.github.io/yjlblog/posts/tech/frontend/","summary":"练习百度的前端笔试题","title":"前端笔试题练习（一）"},{"content":"自定义加载 加载自定义字体 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;在Application中使用Font的loadFont方法，字体的ttf（或其他）文件放在resources目录下。 font=Font.loadFont(getClass().getResource(\u0026ldquo;xxx.ttf\u0026rdquo;).toExternalForm(), 10);\n第二个参数是字体大小\n加载预设置样式 Node.getStylesheets().addAll((getClass().getResource(\"xxx.css\").toExternalForm())); 坑 application文件放在父文件夹下,避免加载资源的麻烦 UI \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;虽然SceneBuilder好用，但是对于复杂布局以及动态元素过多的布局，仍需要手动写代码，用Java进行布局。 字体 字体特效 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;使用Effect库，可以使用一些常见的字体特效，如阴影DropShadow 对齐 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;通过设置节点的对齐方式setAlignment 节点 坐标 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;在设置坐标的时候使用其他节点的preHeight等数值，无反应。似乎没有显式设定尺寸和坐标的话也无法获取对应数据，只能用一些近似计算。（比如Label利用字体和字符长度来计算等） 应用 最小化 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;首先将应用图标从任务栏去掉，方法是在stage外再套一个透明stage（因为该设置默认是有关闭按钮的，所以套在外边）。 transparentStage.initStyle(StageStyle.UTILITY); //将stage的透明度设置为0 transparentStage.setOpacity(0); //stage展示出来 transparentStage.show(); stage.initOwner(transparentStage); 然后将应用最小化到系统托盘，利用java.awt.SystemTray来实现。\n多次启动 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;为了防止将一种应用lauch太多个实例，而将application子类写作单例类。application若多次新建stage，虽然属于一个应用，但是都调用show方法的话都会显示出来，如果从一个应用调用另一个应用需要注意这两点。可以在每次调用前stage.close()保证只有一个stage在展示，也可以使stage不变而改变scene和其中节点。 生命周期 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;application的生命周期是从launch到stop，在实现最小化时将stop改为hide，使得程序可以继续运行。值得一提的是，在本设计中（一种常用设计），从系统托盘打开的是设置窗口而不是ui窗口，所以系统托盘也应采用如上调整，防止打开多个应用。 IDEA+javafx+gradle项目bug记录 和javafx不一定有关系，顺便记一下 Invalid gradle jdk configuration found 和项目的java jdk版本不匹配 ","permalink":"https://intpyjl.github.io/yjlblog/posts/tech/javafx/","summary":"做javafx的一些过程记录","title":"Javafx"},{"content":"【剧透注意，请看完全片后阅读】\n前言 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;千呼万唤的流浪地球2终于在疫情放开后的第一个春节如约而至了，在上映前，笔者便紧密关注着相关资讯，并迫不及待地在预售开启的第一天买了票。又是翻着4年前看完第一部后发的动态感概万千，又是翻出以前买的众筹周边大谈了一番情怀。大年初一，满怀期待地走进影院。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;该怎么去形容我在观看时的感受呢？这一切实在是太震撼太饱满太夺人眼球激动人心了。看到影片开始时太空电梯的超长镜头，我觉得我激动地快要流泪了；看到无人机像蜂群般涌出，又在空中绽成一朵朵烟花，我无声地惊叹；看到周喆直指着图片中的小白点时，我屏息而听，“这个小小的白点，是我们的一切”；我在每一处全场鸦雀无声的地方同样无声地赞叹、揪心、流泪，既被制作顶尖的画面夺取所有注意，也在每个艰难的抉择面前打开脑洞不停思考。在接受完这一场信息量超大的视觉轰炸后，我却头脑空白、无法言语，我毫不怀疑地跟同伴说：“太好看了”，除此之外却似乎再难组织词句。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;在我终于需要向朋友推荐这部电影时，我总算尝试用简短的语言概括了它的特点：流浪地球2超越了近年来科幻片局限于个体命运的小格局，完成了精彩的宏大叙事。它毫无疑问是中国科幻里程碑式的作品，也是世界科幻电影中的杰出之作。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;在二刷并进一步整理了思绪之后，我将从人物主线、电影主题、影片制作等方面对电影的精彩之处进行更为详细的阐述。 流浪地球2 渺小而伟大的人类 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;标题是我在观影前看到的一个描述，在看的过程中我边看边思考，觉得它太合适、太符合角色境遇。流浪地球2中不再有典型的英雄主义式的个人，而只有每一个在无可逃脱的命运中苦苦挣扎的人。第一部中英勇牺牲的刘培强，在本片中一出场就透着一股年轻人（21岁）的憨直气，变得更加活泼可亲。这个角色的命运转变可以从影片开头的一段问话中体现。 地球，是个美好的地方吗？ \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;最开始，他坚决地回答不是，他既无家人，便无牵挂，唯愿“代表人类遨游太空”，倒还能和已经变成星星的家人们作伴。可是初见韩朵朵，这个答案就开始动摇了，当他迎接属于自己的爱情、建立家庭的时候，想必地球成为了他真正牵挂的美好家园。在2044年大暴乱中，我们还能看见他身上英雄的影子，刘培强和韩朵朵在移山计划所面临的前所未有的大危机面前，挺身而出，以少敌多，英雄本色使人佩服。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;可14年风云变幻，人类文明所面临的残酷命运让每一个个体都难以独善其身，集体的决策也并无法照顾到每一个人。一位曾经英雄般的人物却一下子成为了让我怜悯的人。 预告片中就已放出的，MOSS审问刘培强的片段，是片中第一个令我感到无比难过的地方。开始时刘培强那些故作掩饰的表面发言，在他崩溃并质问：“你们明明什么都知道，为什么还要这样？”之后，我才终于读懂。\n他把新衣服上没拆的标签偷偷塞进衣袖，他想起身像个有尊严的人一样发一通脾气，把椅子砸到那堆破铜烂铁上，可却因固定的座椅只是难看地挣扎了几下。他冷静下来，最后什么也没做，只是鞠躬、道歉。他怎能如此可笑、如此狼狈，我看着一个英雄式的人物如此经历自己生活的绝望困境，电影院里有人笑了，我只替他感到难过，因为我也是一个普通人。 后来，他去领物资，这个小小的片段只让人更加难过。我看到一次拯救人类的立功换来了一袋水果，我终于意识到：我不能指望看到一场精彩绝伦的战斗后好像理所应当随之而来的华彩熠熠的人生，这不是什么超级英雄电影，这是时代的一座山，落到每个人头上成了一座大山。“任何超脱飞扬的思想都会砰然坠地的，现实的引力实在是太沉重了”。如今对他而言，“代表人类遨游太空”已成谎言，面试领航员是为拯救家人不得不做的事。此时，地球对于他来说，还会是一个美好的地方吗？当他呼吸着所剩不多的氧气，在月球上摆手拒绝去返回舱时，他还有活下去的渴望吗？结尾时，当师父张鹏最后一次遥望着地球时，再次说出了这句“地球，还是挺美好的”，我多么希望在师父的守望下回到空间站的刘培强，能够因为师父最后留下的温暖，因为天上无数闪耀群星的守护，觉得这个地球稍微变得不那么糟了。\n我想讨论的第二个角色可能稍微有些出人意料——韩朵朵。作为本片两名重要女性角色之一，她一出场就让人印象深刻：哇，好帅。优秀的航天员，在危机中也能冷静判断做出卓越贡献。即便她戏份不多，也足够讨喜。她坐飞机回家的那段情节很多人都很喜欢，她在生命所剩无几之时表现出的积极、活泼、生命力都十分珍贵，能够感染他人，正是“生如夏花”的绝佳体现。可我看这段戏时却也止不住流泪。“人固有一死，或重于泰山，或轻于鸿毛”，有时这不仅关乎人的选择，更是一种命运。虚无的死让人害怕，因为它似乎也会抹去生的意义。刘培强的牺牲尚能称作壮烈的死，我不知道韩朵朵躺在临终的病床上，思考自己的一生时又有一种怎样的感受。放在今日我们也明白，一名航天员需要多少资源才能培养出来，那么曾作为一名肩负拯救世界任务的优秀航天员，曾经驰骋寰宇而今缠绵病榻，她要怎样接受自己短暂而曲折的一生，做到内心自洽？我看着她与往日的战友通话，高兴地大喊着让刘培强加快驾驶速度，我在想，为什么拯救自己看起来比拯救世界还要困难？我在想郝晓晞说的，这不公平。 图恒宇 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;最后想先聊一聊另一位主角图恒宇，我认为这个角色的侧重点与上面两位有所不同。第一遍和第二遍看图恒宇线的感觉有很大的不同，第一次看的时候偶尔会觉得过于冗长，图恒宇本人也一副随时会“黑化”的不稳定状态。不过尾收的很好，确实颇有《星际穿越》的味道了。当图恒宇终于打开大门，见到丫丫时，原本紧张的音乐戛然停止，开门之后，那种家庭的恬静气息几乎是扑面而来，小女孩大声叫喊着跑去和爸爸拥抱的画面充满温情。如果说之前不断重复的视频通话偶尔还会让人觉得有几分做作和拧巴，此处则尽显完全不加矫饰，真诚的、朴素的亲情。 我觉得图恒宇比很多人“幸运”，不管怎样，他的冲动都直接或间接地导致了月球危机的发生，他最后的举动与其说是所谓“拯救世界”，还不如说是填自己挖的坑，很多人都为此牺牲，虽然最终成功了但也失去了太多。图恒宇自始至终就和其他主角立场不同，他是“自私”的，他几乎所有行动的动因都包含直接的个人利益。但最后，他几乎可以视为没有承受任何代价，甚至还获得了在虚拟中的“永恒”。因为我相信虚拟的生命也是有意义的，所以才觉得与他比起来，其他人才是太可怜了。图恒宇作为550W开发团队的一员、移山计划的核心参与者，他比普通人有更多机会接触到最高层的资源，他比普通人拥有更大的力量来反抗集体的决策，我能理解这一现实，但太残酷了。不过，电影最后的彩蛋让我对于这种“不公平”的不适减弱了，图恒宇这条线突然又变得扑朔迷离了起来，我认为这里留下了诸多疑点，如果说在暗处帮助人类的未知力量也是图恒宇，形成了时间闭环，倒是有几分“非他不可”的意思了，如果他其实是那个“暗藏的英雄”的话，我以上对他的评价就需要修改了。 宏大叙事 近年来，不只是科幻题材，许多虚构类作品都表现出这样一个特点——讲不好大格局的故事。无论背景设定多么复杂、世界观多么宏大，最后囿于作者本身视野或笔力的局限，要么把握不好而烂尾，要么只求一个平稳落地，最终还是提炼一个“小”的主题。很久之前我就在某部科幻作品下面看到了这样的评论，说：更大的主题不好把控，不如聚焦这些小的问题，在能驾驭住的范围做好就可以了。这种“小格局”本身并没有什么错，着眼点小也有其独特的魅力。但如果到最后，放眼所有文艺作品，竟连一部讲了并且讲好了宏大主题的片子都找不出来，难免要让人怀疑整个行业的水平是否下滑了。在流浪地球2上映之前，正好经典IP阿凡达也时隔多年出了续作，不过风评并不佳。《阿凡达2》明明背景设定的是两个星球上不同文明、种族间的冲突，最后问题的落脚点居然回到了家庭问题，实在是让人感到匪夷所思。\n在这样的大环境下，流浪地球2最突出的一点，便是超越了近年来科幻片局限于个体命运的小格局，完成了精彩的宏大叙事，它对文明命运的深入探讨真正地让人心神激荡。 “宏大叙事”这个词，我是在疫情期间知晓并开始频繁使用的。很巧的是，流浪地球两部曲，正好在疫情出现和放开前后的两个春节上映。对我而言，在后疫情时代再看这个故事，会给人很多不一样的感受。 如果没有疫情，我可能不会去想，“只有一半人能进入地下城”这一事实背后，另外一半人，他们是如何接受、如何挣扎和死亡。朋友形容，这种条件构造了类似大逃杀的环境。就如刘培强被MOSS质问为何选择带妻子而不是岳父进入地下城，生存机会有限，每一个选择都生死攸关，不管怎么做都很残酷，在这种情况下，你可以理解每一个人的私心。电影中有一处镜头回应了我的想象，在月球危机迫在眉睫之时，镜头扫过了世界各地的仍在故乡、守望天空的人群。这里很值得琢磨，除了有一处出现暴动的场面外，其他的人继续着自己习以为常的生活、望着一如既往的家乡风景、紧紧握住身边家人的手，平静地，望着天空。此时我意识到，电影所给出的方案既残酷又理想化，在现实中，很难想象有多少人能如此沉着地接受既定的命运和未定的希望。\n诚恳地说，近三年我其实是越来越讨厌宏大叙事这个词，在现实中看，它像是一个巨大的谎言，掌控着所有人的个人叙事。在这个谎言里，个人的需求变得无关紧要，而集体所追求的目标看起来虚无缥缈。我越来越倾向一种个人优先、享乐为上的态度。而从我个人一直以来的观念来讲，数字生命计划才是我所认可的人类的归宿。甚至当我询问我所认识的、习惯于从全局角度思考的长辈时，ta也认为，如果放自己处于同样的境遇中，ta是无暇考虑100年后的人类命运的，还是维持自己的生活最要紧。平心而论，图恒宇所代表的数字生命计划并不愚蠢，甚至蕴含了部分人心中的真理也说不定。 但是，对于影片中给出的一种不同的解答，我也完全能够理解和接受。周喆直的每一次发言，都深深地撼动了我的心。如果能完全投身于这种崇高的信念，想必也能赋予生命宝贵意义。我认为影片在处理上做的最好的一点，就是毫不避讳地展示了宏大叙事中的个体困境，充满了人文关怀，也正因此，才能加深宏大叙事的合理性。希望，像钻石一样宝贵，每个人都怀揣着对于人类文明的未来的希望，却又面对着个体难以逃脱的、令人绝望的命运。我被希望所打动、热泪盈眶，因为疫情，我也与他们的痛苦共情。我着迷于个体命运与文明命运之间拉扯纠葛的关系，看到渺小和伟大都同样美丽。 PICK UP 在流浪地球2中似乎特别喜欢call back，除了存在感极强的一部曲名言“行车不规范，亲人两行泪”之外，贝加尔湖钓鱼也重新充当了flag。张鹏与刘培强这对师徒间关于“地球是否美好”的对话和点脑门的动作都在影片首尾出现，医保梗、危难时大喊“妈妈我要回家”这几个包袱抖了好几次，更有地球之光、监视器等伏笔暗埋，十分巧妙。 流浪地球2在国际化这块做的比三体电视剧要好太多了，三体电视剧还在扭扭捏捏地用A国、M国这种过家家式的表达，流浪地球2已经是在国际对话部分下足了功夫。通过周喆直之口传达了人类命运共同体的呼喊，号召通力合作，既展示了中国在国际对话场上的风采，又不避讳地体现了中国所遇到的困境。很显然，刘慈欣的科幻一直透露出浓浓的中式色彩，带上地球流浪也好，老一辈航天员站出来也好，这些情节真真切切是西式表达里缺少的。所以他的科幻情怀，真的会最让我们感动。（以及，他还是那么喜欢俄罗斯） 流浪地球2的艺术性亦是绝佳，电影中有许多场面的构图让人震撼到屏息。其中，我最为喜欢这一幕。 一个不起眼的轴承环，见证了刘培强一生中的许多重要时刻，关联了小家与大家。起初，当它从动力手臂上崩开，占了一秒的特写镜头时，我们还以为它只是一个中式笑话的小插曲。但当刘培强捡起它，像求婚一样递给韩朵朵时，比SPY×FAMILY中用手榴拉环求婚更让人会心一笑，更具有一种硬核浪漫，打动彼此也打动观者。最后的最后，他用小小铁环框起人类最重要的那个小小白点时，我感到天地寂寥，万物无声，终生只能行走在坚实土地上的我，此刻却能感到心与宇宙同频共振。我感到我和我的家人、国家、文明、宇宙正相处一处。如此渺小的我，与伟大的文明相拥，如此渺小的文明，与广阔宇宙相容。\n我知道已被忘却 太阳系的往事太久太久 但那一时刻要叫我一声啊 当鲜花重新挂上枝头 啊，地球 我的流浪地球 电影制作 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;简短来说，流浪地球2这部电影在诸多方面都下足了心思，光看场面就足够震撼，机械设计让人直呼天才，就连电影中多处出现的UI，都是由单独部门进行设计。电影显示了中国当前电影工业的顶级制作水准，所有认真打磨的写实的细节最终构筑起一个真实可信的科幻世界。 总结 ","permalink":"https://intpyjl.github.io/yjlblog/posts/insight/wanderingearth2/","summary":"⌈这个小小的白点是我们的一切⌋","title":"流浪地球2"},{"content":"前言 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;今天偶然听了理芽first album的两首专辑歌，被非常非常强烈震撼到了，以前神椿都只是听asu，但今天听到的理芽的《NEUROMANCE》和《孤独之人》将她的个人魅力充分展现了，非常打动人。我也由此认识了音乐创作者笹川真生——真是天才。 youtube才32万再生\nbilibili才6.4万播放\nNEUROMANCE 很切合专辑名NEW ROMANCER 开头两句“雨”、“乐园”显然都意有所指，此时本曲想要讲述的故事还不清晰，但却已经不太符合听者对“赛博浪漫”的幻想，基调更为悲伤。\n这时电脑、键盘、液晶等意象都已出现，“网络世界”的相关话题开始被抛出，液晶接受与输出信息，是人们在互联网上交流和表达的代表。但是，我们为什么要从液晶寻求空白处的答案？明明是在要求我们思考？此处已经开始显露一些问题。同时，MV的主角也已出场。\n随后一个简单的场景过渡，用“听吧”开启歌者的讲述。（这里联想到了《言って》这首的开头，在音乐的表现上算是有一些异曲同工之处，简短的单词说完之后，是一段较长的间奏，此时使用的配器开始变得更多、声音更重，因而冲击力更强，将整体氛围一下子烘托起来）\n随后出现的场景展现出了歌曲的世界观，对于初次看到MV的人来说很震撼：灰暗的世界，一只只有着黑白线条、画着奇怪的几何图案的手被用线连接到天上，悬浮在空中，同时以一致的姿势刷着手机。此时，我们已经隐约能猜到歌曲想要针对的现象和想要表达的内容，这个主题说起来甚至有些老套ww（然而看完的感受并非如此）。\n这句不算非常明白，直觉的理解是网络上与人社交的结束语。猜测一下，也许是指网络上与人的谈话开始又结束，对话死去、甚至一段关系死去，但是痕迹却是永恒保留？\n接下来，两个拍摄画面，结合歌词，显然指的是互联网用户分享美食摄影、生活影像的普遍现象，然而，明明不了解用法（并没有多么充分地感受吃/喝/聚会/游玩本身的快乐）却还要去吃/喝/聚会/游玩，然后再在互联网分享是为什么呢？\n⌈人就是这样才知晓爱为何物吧⌋\n这里的回答有点出乎我的意料，不是“认可”、“尊敬”这样的字眼，歌曲选择了一个意义更为宽泛、从各种角度来说都很宏大的主题作为答案。但是我非常认同、非常理解。就在前一天，我还在跟朋友进行探讨时，说到人似乎有渴望被爱的本能，提到“创作也是为了被人所爱”等等。这个形容包括了相当广泛的内容，“被认可”、“被尊重”甚至于“受欢迎、有名气”这样的含义大概也被包含在其中，但简单地形容“在赛博世界分享生活”的目的是“受人认可”，似乎程度太低了。（当然，也许在为了分享生活而体验生活的过程中，也能最终爱上生活呢？这大概也算是“知晓爱”吧）\n“那片天空”是哪里呢？想必不是现实的蓝天，而是虚拟的空间吧。但不只是心灵，甚至连身体也在虚拟中栖息？这似乎有些科幻。根据歌曲评论，我了解到本歌歌名是neta《神经漫游者(Neuromancer)》———赛博朋克的鼻祖。很遗憾我没有看过这本小说，但大概MV中的很多镜头都是根据小说的剧情而来的，不能简单地根据个人感受来解读，在我没看过《Neuromancer》的情况下，只能先从个人猜想出发了。\n依稀记得某一位有名的物理学家预言过，随着科技的发展，人会变得越来越向内看、向内思考，而不是向外发展。在从前，这种专注于自身的精神世界还没有可以着落的点，人仍然主要栖身于真实的世界中，而如今却可以依托于网络，让这个世界在虚拟中更加膨胀，所以我们从现实世界中“走神了”，如此矛盾的是，我们明明实际地存在于此处，却看起来并不归属于这里。\n“言语与价值观 都毫无关系”则透露出了非常强烈的虚无感，乍一过渡在表意上看起来有些突兀，但是却切中了互联网重度使用者的实际感受。人本能向往的生存状态是“拥有自主决定权，投入到令人满意的活动中去”，而实际情况却是找不到可以投入精力的所谓有价值的事，没有遇到值得思考的大概是有意义的问题，就已经被信息的洪流持续地刺激，被低层次的思考毫不费力地占据了心智，不再能去认知，更无法去表达。而因为寻找不到意义，所以唯一留下的就是生活自身的荒诞，万事万物的虚无。在这种思考方式之下，“价值观”不过是束缚真实世界的社会动物的领带，而不是享乐主义者生活的标准。（此处参考了《我们为何无聊》一书，可能扯远了，也可能表意不够准确，推荐阅读原篇）\n“沉溺于春天的你”。春天是美好的，但沉溺于春天却怎么看也不像是正常的。曲中从黑色的主角的视角（根据之前的镜头，黑色的怪物里也是一个小姑娘）出发，反复质问电车里、阶梯教室里、教学楼前、餐桌前的众人，为什么看着手机，我向你反复地问好、告别，但你要和谁共处呢？究竟和谁身处同一空间呢？这里用一句热评的吐槽，确实很“疼痛小作文”（乐，还得是李梅小姐），不过表达也很直白。\n当然更有意思的是后面的发展，一直与众“手”格格不入的小黑也拿起了手机，在夜晚回家的路上挑了一张合照发ins。\n接下来又是我非常喜欢的一段。歌词到“录下来的天空”的时候，小黑面对的屏幕上却是最开始拍摄的食物的图片。“被录下来的天空”显然是指在虚拟世界中被记录的生活，“只是眺望”这些虚拟的记录，而非欣赏真实的天空，显然又印证了前面的判断。\n“最讨厌”的对象指的可能是网络、网络社交或者他人的认可，人一边讨厌他人的打量与评判，一边又渴望着认可与喜爱，一瞬不瞬盯着点赞数；想要变得强大，却还是无比在意简单的数据，为其赋予沉重的意义。或大或小，这样的事情都一直在发生。（《黑镜》有一集应该讲过这个话题）\n“人就是这样才知晓爱为何物”这句又再一次地出现，呼应了之前的内容。在赛博空间中，人的孤独与对爱渴望的本能都被放大了。\n在这之后是一段非常强的演出。表现了渴望关注、渴望认可而过度呼吸的女孩，明明是孤身一人，却感觉被无数目光盯着，明明是自由的，却仍被看不见的枷锁束缚着，被一个简单的欲望压倒，直到看见数据的变化才能笑出来。最后，白色的线缠绕到主角的身上，也意味着她终于和别人“连接”了起来，但其实却是消解了真实的自我。\n“人群并不是我的朋友，他们只会注视着我，对我下判断。我的朋友是那些真正爱我、关心我的人”。无端想起了加缪的这句，记不清原句了，但是很长时间我都会用这句反复提醒自己。\n可能这就是刺眼吧 接着是重复副歌部分，“表盘”是场景里多次出现的圆环图案，像宗教一样，大概是“手”这一派的象征。“不安”可能是现实中感到的焦虑，也可能是对网络感到的不信任，快感则是逃避这种不安而沉溺于其中的刺激。\n究竟是真能从这其中找到生活的意义，寻求到自己的答案，还是进入了不可逃脱的深渊？这样的日子导向的的究竟是幸福的结局，还是无法挽回的悲剧？或者干脆承认生活不过是永恒的虚无。\n这里主角则仿佛成了“不成熟”的孩子，向着不能理解的“大人世界”反复质问，这里倒不想再写什么解读了，为什么突出年龄身份？理由都不需要在书中寻找，公众媒体都在天天反思了。\n书本里的智者，也再无人可以对话，更没有人还在思考、传达了。\n第一次看到这句歌词的时候忍不住笑了，表达真是出乎意料的直白。主角一边被更多的白色缠绕，一边还在为每个人都低着头走向车站的景象感到糟糕w正像指点他人边走边看手机的我，成年后就迅速掌握这一技巧的可笑样子。\n很震撼的一幕，主角仰望天空中的巨大人脸，瞬间显得如此渺小，很快就被其吞噬。这里终于揭示了世界观的全貌。根据粗略浏览的资料，大概是跟《神经漫游者》的剧情有关，“由AI所掌握的全体人类”之类。不过，小说也是为了表达某个主题，我们不妨通过两层抽象尝试直接接触故事的核心。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;想要得到这种完全掏心的咨询服务，我们就必须改变想法，不要认为人类都是不可分割的个体，不要坚信每个人都有自由意志，能决定什么是好、什么是美、什么是生命的意义。从以前到现在，人类都是自由实体，由叙事自我叙写的故事所操纵。但在未来，每个人都会是整个巨型全球网络的一部分。 这是几天前被人分享的《未来简史》的一段，没想到放在这里作为一种解读是如此合适。 终于写到了结尾，中间几次有点写不下去，自觉对这个问题还没有找到自己满意的答案，而且书还读得太少。本篇乐评只为欣赏整个作品，包含词曲编唱MV在内都很优秀，不愧是理芽！除此之外不批判任何，也不指点任何，毕竟我只是“完全的电波的奴隶”罢了。\n本作最喜欢的地方 ","permalink":"https://intpyjl.github.io/yjlblog/posts/insight/neuromance/","summary":"⌈从那时起我们便完全沦为电波的奴隶⌋","title":"NEUROMANCE"},{"content":"前言 还没写完 ","permalink":"https://intpyjl.github.io/yjlblog/posts/insight/moonlight/","summary":"⌈不惜偷窃也想要这份爱吗⌋","title":"月光"},{"content":"前言 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;开心麻花推出的全新科幻喜剧，7.29淘票票评分9.5的科幻喜剧。带着很高的期望去看了，结论是可圈可点但评分肯定得降。打着科幻的tag但最好不要带着科幻的预期去看，所谓“科幻”的几个剧情爆点应该更接近童话，当我看完简抒感想时，都还与人争论起了电影小高潮处一段剧情的合理性，老毛病了(*^_^*) 那么回归正题。如果让我用关键词来客观概括这部电影，我会用两个词“孤独”和“浪漫”。人类所能感受到的最大的孤独和在宇宙尺度的能感受到的极致的浪漫碰撞在了一起~（后一点可能稍有夸张，至多地月系尺度，都没大到太阳系）确实有一些美妙之处\n茫茫宇宙，有我一盏星星灯火 最为碰巧的是，我们在去影院的路上正好讨论了关于孤独的话题，我还表示了“一个人更好”的决心、下了“孤独是亦一种生活方式”的断言，但没想到开篇就是地球毁灭、宇宙中只留下了最后一个人类的场面，一时有些汗颜。（os:孤独最好是一种选择，而不是一种处境……）\n观影前听说本片讲的是沈腾所演的角色一个人在月球上生活的故事（os:《月球救援》？能种土豆吗）。看了开篇设定，倒是让人想到几年前的另一部科幻电影《太空旅客》：男主角在星际旅行中意外醒来，发现自己要独自在飞船上生活到死了。寄蜉蝣于天地，渺沧海之一粟，而无人可与共适佳景。于是他故意弄坏装置，唤醒了另一位旅客，抱团取暖的两人在浩渺星穹之中竟也能享受到生活的浪漫。\n而《独行月球》开局条件更为苛刻，（主角以为）计划失败、人类灭绝，他永远回不了故乡，也没有任何伙伴，只有在条件恶劣的月球上凄惨地度过余生。在目睹陨石与地球相撞的那一刻，他的希望消失、心火熄灭、意义消解、暗恋再无结果、旅行已无归途，铺面而来的只有巨大的窒息、荒谬和绝望，找不到继续生活的理由，所以浑浑噩噩过了几天后，便打算结束自己的生命。\n故事发展没什么问题，不过我个人体会是这里的孤独感塑造稍有欠缺，“独行”的“独”之一字不够凸显（上面所述心理活动其实都是笔者个人脑补）。大概是因为要顾及喜剧表现，多制造笑点所以牺牲了这一部分罢，但“苦中作乐”的“苦”确实不太够啊——\n后面的发展是主角遇到了一只（聪明得有点瘆人、暴力得有点吓人）的袋鼠，“相依为命”、打打闹闹地一起生活（本片的欢喜冤家担当）。而另一方面，地球上仍有人类存活，存活的人类躲进了地下（什么《流浪地球》），而月盾计划的成员开始实时直播孤独月的月球孤独生活。这里很难不想起《楚门的世界》，但剧情发展到此处提出这一点倒也合情合理，算是本片亮眼的设定之一。\n顺带一提，月盾指挥官马蓝星全球广播的场景也很有《流浪地球》既视感，都是末日当头、人心惶惶的场面，《流浪地球》的这一剧情是一大败笔，而本片马蓝星的发言倒确实鼓舞人心，话术高超。\n下面直接快进到本篇的一个高潮桥段吧！\n主人公燃起的希望再次破灭，心如死灰，在石碑上刻下“世界上最后的人类”，而此时监控着一切的马蓝星队长让全球人类点亮星星之火，灯光照向夜空，指引孤独月回家的路。\n这里的想法确实非常浪漫，一时间我脑海中也浮现出太空望远镜所拍摄的夜晚的地球🌏.城市夜空的万家灯火清晰可见，那是人类创造的文明在闪耀；众人拾起炬火，则是我们文明的存续。\n不过我与人争议的也是这一片段😀，知名科普读物《what if》里探讨过“所有人类用激光笔照射使月球改变颜色”的可能性，手电筒的光强度不够，损失较快，所以至少也得是激光笔，而片中倒也确实出现了强光源。实行难度我不好说，但能在月球上看见字基本是胡扯🥲\n顺带一提，本片又双叒致敬了E.T！上一部致敬E.T.的是同样不太科幻的科幻喜剧《疯狂外星人》（而且同样是改编）。 致敬的必要性？ \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;本篇的感情线（如果能称作感情线的话），在我看来绝对不是本篇浪漫因素的核心，我的感想只有：沈腾又在追女神，沈腾哪部电影不是在追女神（笑）。爱情喜剧喜闻乐见，但是认真你就输了~和孤独一样，浪漫也缘于个人渺小与宇宙无垠的强烈对比，因为以区区人类之躯，亦可畅游星穹、点亮星球、阻挡彗星、造就星环，像虫子一样渺小的人类，抱团在一起，似乎可以跨越千难万险，使文明延续，说这是科幻的永恒主题应该也不为过。 \u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;本片最后，独孤月为人类牺牲了自己。情节发展不太意外，上文所述《流浪地球》（吴京）、《太空旅客》（男主，虽然没死）都有类似剧情。此外，精准地利用太空服的微弱动力趋势撞上小行星这种剧情emmmm…实在很难说服我，个人有点出戏。不过，行星（以及独孤月）的碎片变为星环永远围绕蓝星（双关）的结局确实很不错，非常巧妙，让我觉得“就是为了这点醋才包的这顿饺子”的程度。这一点也是刚好戳中了我：我在刚开始接触物理知识的时候，觉得很浪漫的一点是，当我死去之后，组成我身体的每一个分子、每一个原子都会再次成为这个世界的一部分，成为山川河流、日月星辰的一部分，人从自然中来，最终又归于自然，让我感觉很好。即便我作为一个普通人类是如此渺小、生命短暂，但组成我的每一部分都永不消亡（不觉得很美妙吗） 二编： 拖了很久才收尾导致写结尾部分时记忆也比较模糊了，有些灵光一闪的想法也可能没捕捉到。\n顺便，在此期间也看了不少影评，看见有一位的影评说：尬得要命，“只推荐年龄不超过十岁和笑点低得比较奇特的人看”，虽然点评毒辣但我还比较赞同，因为我恰好是后者hh。就喜剧部分来说，本片和沈腾之前的电影，比如《夏洛特烦恼》相比，多了很多“现实梗”，比如流浪地球梗、演员梗、沈腾其他作品梗，这种不太传统的“喜剧”部分让我觉得有点意外，确实比较像小品，像小品也不是什么太大的问题，只要别发展到像春晚小品就行。\n看到的影评中，常看的几位影视up主基本都是偏差评ww普遍夸奖的地方有沈腾的演技和影片特效（这两点确实满分）。豆友也比较严格，评分（截至8.17）已经降到6.8，属于是不太会推荐人看的那一级，但恰恰是我关注了很久的一个长期聚焦科幻相关主题的公众号，给了这部电影极高的赞扬。很显然，中国科幻迷对国产科幻片都抱有极大的宽容（我也是如此✌），每一部电影都是中国科幻的一小步，当《流浪地球》造就“中国科幻电影元年”之后，每一次尝试，都是在铺就前往黄金时代的阶梯，我是如此坚信的。\n","permalink":"https://intpyjl.github.io/yjlblog/posts/insight/yqdx/","summary":"没有科幻的内核，但有科幻的浪漫","title":"独行月球"},{"content":"“你知道，有些鸟儿是注定不会被关在牢笼里的，它们的每一片羽毛都闪耀着自由的光辉。”\n此时此刻，恰如彼时彼刻。\n后悔，最后悔的就是在火车上看《肖申克的救赎》，以为自己高瞻远瞩独树一帜，没想到把自己讽刺了。 也许人生本就是一场历练……\n到达目的地时，发生了戏剧化的一幕。车在马路中间，前不着村、后不着店的地方停下来了。猝不及防的我第一反应：司机有事？看到司机往这侧走来开门，我想起朋友圈晒出的、豪华得各有特色的酒店，望向远处的大厦：是那里吗？……而我完全没有想到，司机直接领着我们往右边看起来是工地的地方走去！\n真就好似那个漫画剧情（这么老套，你一定见过）\n再就是淋浴间，那个倾斜角度属实难绷，水堆到另一边完全流不掉，这里是南方啊！蚊子快乐屋…… 虽然嘴上有各种吐槽，但这些问题忍一忍也不是不能接受。可是泡面为什么只有我最讨厌的红烧牛肉？😭\n","permalink":"https://intpyjl.github.io/yjlblog/posts/life/20220525/","summary":"\u003cp\u003e\u003cu\u003e“你知道，有些鸟儿是注定不会被关在牢笼里的，它们的每一片羽毛都闪耀着自由的光辉。”\u003c/u\u003e\u003c/p\u003e","title":"入住隔离点（你管这叫隔离酒店？）"},{"content":"“人生中有些时刻是比其他时刻更为闪耀的，正是这些时刻构筑起了我们生活的意义”\n永远年轻，永远自我感动得热泪盈眶，永远头脑发热说做就做\n去晚了，只听到最后一首歌，还是很激动。当操场的远光灯（也许是这个名）倏地关了，尖叫响起时，我又热泪盈眶了，虽然没有安可曲的机会了，错过了很多精彩的节目，但这一瞬已成为我心中这一晚的最高光时刻。只剩同学们打开的手机手电筒，光芒一点一点，像晃动着的星星。\n于是我想，人生中的有些时刻是比其他任何时刻更加闪耀的，正是这些瞬间构筑起来我们生活的意义。（感觉好像把两个人说的话拼接起来了，但是前半句肯定源于《人类群星闪耀时[yjl解读版]》）\n回村路上，我计划回去后一定要把我当年的书摘找出来，拍张照发个朋友圈记录一下，但很遗憾，我没有摘抄这句话。这么个解读法也离题太远，已经不是这本书想传达的主要意思了\n以前特别希望能站在城市高处，看整个城市的灯光由远至近，或是由近至远慢慢亮起。但当最闪耀的那盏灯熄灭，只剩星星灯火的这一瞬间，却使我第一次体会到了想象中“华灯初上”的浪漫感觉。可惜它是那么短暂，以至于现在我都无法再靠假想构筑出这种感觉（迫真叹气）。 今天的另一个幸福时刻是下午去逛超市，音乐很温柔，莫名其妙的满足。 以后搞笑截图放这里：(今天跟妈妈讲这件事) ","permalink":"https://intpyjl.github.io/yjlblog/posts/life/20220521_1/","summary":"\u003cp\u003e\u003cu\u003e“人生中有些时刻是比其他时刻更为闪耀的，正是这些时刻构筑起了我们生活的意义”\u003c/u\u003e\u003c/p\u003e","title":"灯光与草地演出"}]